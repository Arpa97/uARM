\achapter{BIOS \& System Library}

\asection{BIOS}\label{sec:man:bios}

\asubsection{Bootstrap Function}

The bootstrap program bundled with \uarm{} installation initializes hardware facilities and starts execution.
The code for the bootstrap routine can be found in the file \texttt{BIOS.s}.

The BIOS code performs the following operations at boot time:

\begin{enumerate}
\item Populate of the Exception Vector with Branch instructions to ROM Level Exception Handlers;
\item Set default Exception States Vector entries with \texttt{Branch to PANIC} instructions;
\item Retrieve Entry Point from core binary code loaded in RAM;
\item Set execution mode to System mode with ARM ISA and all interrupts enabled;
\item Set Exit Point and \texttt{RAMTOP} value;
\item Clear all used scratch registers;
\item Jump to Entry Point.
\end{enumerate}

\texttt{BIOS.s} source file also contains the code for ROM Level Exception Handlers (see Sec. \ref{sec:man:romExceptionHandlers}) and ROM Level Services; the default installation directory of this and the other support files is \texttt{/usr/include/uarm/}.

\asubsection{ROM Level Services}

ROM Level Services are requested by issuing a \asm{SWI} instructions with certain parameters and are served by the BIOS code:

\asubsubsection{Halt}

By executing \asm{SWI \#1}, the BIOS will print "\texttt{SYSTEM HALTED.}" on Terminal 0 and shut down the virtual machine.

\asubsubsection{Panic}

By executing \asm{SWI \#2}, the BIOS will print "\texttt{KERNEL PANIC.}" on Terminal 0 and enter an infinite loop.

\asubsubsection{LDST}

A \asm{SWI \#3} instructions will begin the loading of the processor state stored at the address loaded into \register{a1} register to actual processor's registers, checking destination mode and setting only the right register window.

\asubsubsection{Wait}

By executing \asm{SWI \#4}, the BIOS will put the machine in IDLE state waiting for an interrupt to wake up the system up.

\asubsubsection{System Calls / Breakpoints}

If a \asm{SWI \#8} or \asm{SWI \#9} instructions is executed, the syscall handler passes up the call, setting the right cause in \register{CP15.Cause} register.

\asection{System Library}\label{sec:man:systemLibrary}

System library is provided by \emph{libuarm}, it offers a set of methods to access low level functionalities from \emph{C} language:

\asubsubsection{\instr{tprint(char *s)}}

Print a '\textbackslash0' terminated array of chars to Terminal 0.
This function uses busy waiting to wait for the device to be ready.

\asubsubsection{\instr{HALT()}}\label{sec:man:HALT}

Request BIOS Halt service.

\asubsubsection{\instr{PANIC()}}

Request BIOS Panic service.

\asubsubsection{\instr{WAIT()}}

Request BIOS Wait service.

\asubsubsection{\instr{LDST(void *addr)}}

Request BIOS LDST service setting \register{a1} to \texttt{addr} value.

\asubsubsection{\instr{STST(void *addr)}}

Stores the actual processor state in state\_t structure pointed by \emph{addr}.

\asubsubsection{\instr{SYSCALL(unsigned int sysNum, unsigned int arg1, unsigned int arg2, unsigned int arg3)}}\label{sec:man:SYSCALL}

Generates a software exception leading to kernel defined Syscall handler.
\register{a1} is loaded with \texttt{sysNum}, \register{a2} is loaded with \texttt{arg1}, \register{a3} is loaded with \texttt{arg2} and \register{a4} is loaded with \texttt{arg3}

\asubsubsection{\instr{BREAK(unsigned int arg0, unsigned int arg1, unsigned int arg2, unsigned int arg3)}}

Generates a software exception leading to kernel defined Breakpoint handler.
\register{a1} is loaded with \texttt{arg0}, \register{a2} is loaded with \texttt{arg1}, \register{a3} is loaded with \texttt{arg2} and \register{a4} is loaded with \texttt{arg3}

\asubsubsection{\instr{getSTATUS()} / \instr{setSTATUS()}}

Manipulate Current Program Status Register (\register{CPSR}).

\asubsubsection{\instr{getCAUSE()} / \instr{setCAUSE()}}

Manipulate Exception/Interrupt Cause register (\register{CP15.R15}).

\asubsubsection{\instr{getTIMER()} / \instr{setTIMER()}}

Manipulate Interval Timer.

\asubsubsection{\instr{getTODHI()} / \instr{getTODLO()}}

Returns the upper/lower part of Time of Day 64-bit register.

\asubsubsection{\instr{getCONTROL()} / \instr{setCONTROL()}}

Manipulate System Control Register (\register{CP15.SCB}).

\asubsubsection{\instr{getTLB\_Index()} / \instr{setTLB\_Index(unsigned int index)}}

Manipulate TLB Index register.

\asubsubsection{\instr{getTLB\_Random()}}

Returns TLB Random register.

\asubsubsection{\instr{getEntryHi()} / \instr{setEntryHi(unsigned int hi)} / \instr{getEntryLo()} / \instr{setEntryLo(unsigned int lo)}}

Manipulate Page Table Entry Hi and Entry Low registers (\register{CP15.R2.EntryHi} and \register{CP15.R2.EntryLow}).

\asubsubsection{\instr{getBadVAddr()}}

Returns Faulting Address register (\register{CP15.R6}).

\asubsubsection{\instr{TLBWR()}}

Write the contents of \register{CP15.R2} to the TLB slot indicated by TLB Random register value.

\asubsubsection{\instr{TLBWI()}}

Write the contents of \register{CP15.R2} to the TLB slot indicated by TLB Index register value.

\asubsubsection{\instr{TLBR()}}

Read the contents of TLB slot indicated by TLB Index register value to \register{CP15.R2} register.

\asubsubsection{\instr{TLBP()}}

Scan the TLB searching for a pair that matches \field{VPN} in and \field{ASID} in \register{CP15.R2.EntryHi} or that has \field{G} flag set in \register{CP15.R2.EntryLo} and is \field{V}alid, if a match is found, its index in the TLB cache is stored as TLB Index register value, otherwise that register will have the most significant bit set to 1.

\asubsubsection{TLBCLR()}

Set all TLB contents to 0.

\asubsection{Additional Libraries}

Two more simple libraries are provided in addition to the system library:

\asubsubsection{\texttt{ulibuarm}}

A simple subset of \texttt{libuarm} to be used by user mode programs, only exposes a mean to request system calls through the same \instr{SYSCALL} instruction; see Section \ref{sec:man:SYSCALL}.

\asubsubsection{\texttt{libdiv}}

This library implements integer division and module operations that are not provided by the processor instruction set, it must be linked together with any program that uses divisions.

