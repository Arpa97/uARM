\achapter{Processor}
The \uarm{} machine runs on an emulated ARM7TDMI processor, with both ARM and Thumb ISAs implemented (Thumb is still a bit buggy right now), which is able to perform each operation listed in \emph{ARM7TDMI Data Sheet} (a brief summary is shown below) and to accept painlessly binary programs compiled with the Gnu C Compiler for ARM7 architecture.

\asection{Operating modes and Processor registers}
The processor can work in seven different modes:
\begin{itemize}
\item User mode (usr) - regular user process execution
\item System mode (sys) - typical privileged mode execution (e.g. kernel code execution)
\item Supervisor (srv) - protected mode kernel execution
\item Fast Interrupt (fiq) - protected mode for fast interrupt handling
\item Interrupt (irq) - protected mode for regular interrupt handling
\item Abort (abt) - protected mode for data/instruction abort exception handling
\item Undefined (und) - protected mode for undefined instruction exception handling
\end{itemize}

In each mode the processor can access a limited portion of all its registers, varying from 16 registers in User/System modes to 17 registers in each protected mode in ARM state (only protected modes have the 17th register, it automatically stores the previous value of the Program Status Register when entering an exception) plus the Current Program Status Register (CPRS), which is shared by all modes.

The lower 8 registers in addition to the Program Counter (R15) are common to each "window" of visible registers, each protected mode has its dedicated upper 2 registers and Fast Interrupt mode has all the upper 7 unique registers to allow for a fast context switch, while System and User mode share the full set of 16 general purpose registers.

\vspace{5px}
\begin{adjustbox}{center}
\input{\specsd/tex/tables/ARM_reg.tex}
\end{adjustbox}
\vspace{5px}

Even if the base 16 registers are defined as general purpose registers, there are some conventions adopted by the compiler in their use. The following list shows the full set of processor register visible in each mode with their conventional meaning:

\begin{itemize}
\item R0 (a1) - first function argument / integer result
\item R1 (a2) - second function argument
\item R2 (a3) - third function argument
\item R3 (a4) - fourth function argument
\item R4 (v1) - register variable
\item R5 (v2) - register variable
\item R6 (v3) - register variable
\item R7 (v4) - register variable
\item R8 (v5) - register variable
\item R9 (v6/rfp) - register variable / real frame pointer
\item R10 (sl) - stack limit
\item R11 (fp) - frame pointer / argument pointer
\item R12 (ip) - instruction pointer / temporary workspace
\item R13 (sp) - stack pointer
\item R14 (lr) - link register
\item R15 (pc) - program counter
\item CPSR - current program status register
\item SPSR\_\emph{mode} - saved program status register
\end{itemize}

When the processor is in Thumb state the register window is halved, showing 12 registers in User/System mode and 13 registers in protected modes (the last register is the same dedicated SPSR register as in ARM state) in addition to the Current Program Status Register, common to all modes. 

Only the first 8 registers (R0 $\rightarrow$ R7) are general purpose, the higher 3 are specialized registers that act as Stack Pointer, Link Return and Program Counter. Each protected mode has its own banked instance of Stack Pointer and Link Return in addition to Saved Program Status Register to allow for faster exception handling. 

\vspace{5px}
\begin{adjustbox}{center}
\input{\specsd/tex/tables/Thumb_reg.tex}
\end{adjustbox}
\vspace{5px}

\asection{System Coprocessor}

CP15 provides access to a total of three 64-bit and one 32-bit registers which give additional information and functionalities to regular processor operations:

\asubsubsection{R0 (IDC) - ID Codes}
Register 0 is a read-only register that contains system implementation information such as \emph{Processor ID}, \emph{TLB type}, \emph{Memory Protection Unit type}, \emph{Cache type} and \emph{Tightly Coupled Memory type}.

\asubsubsection{R1 (SCB) - System Control Bits}
Register 1.SCB is the System Control Register, this register holds system-wide settings flags.
See sec. \ref{sec:manual:systemControlRegister} for further details.

\asubsubsection{R1 (CCB) - Coprocessors Access Register}
Register 1.CCB shows which coprocessors are available. Values can be written to this register to enable/disable available coprocessors a part from CP15.

\vspace{5px}
\begin{adjustbox}{center}
\input{\specsd/tex/tables/CP15_CCB.tex}
\end{adjustbox}
\vspace{5px}

\asubsubsection{R2 - Page Table Entry}
Register 2 is a 64-bit register which contains the actual loaded Page Table Entry when MMU is enabled. Its structure is the same as the Page Table Entry described in sec. \ref{sec:man:virtualMemory}.

\asubsubsection{R15 (Cause) - Exception Cause}
Register 15.Cause contains the last exception cause, it can be read or written by processor.

Memory Access exception causes are:
\\
\\
\begin{tabular}{ll}
Memory Error & = \texttt{1}\\
Bus Error & = \texttt{2}\\
Address Error & = \texttt{3}\\
Segment Error & = \texttt{4}\\
Page Error & = \texttt{5}\\
\end{tabular}

\asubsubsection{R15 (IPC) - Interrupt Cause}
Register 15.IPC shows on which lines interrupts are pending, when interrupts have been handled the value of this register is updated.

\asection{Execution Control}

The processor behavior can be set up by modifying the contents of two special registers: the Current Program Status Register (\register{CPSR}) and the System Control Register (\register{CP15.SCB}).
Each of the two has a special structure and changes the way the system operates.

\asubsection{Program Status Register}

The CPSR (and SPSR if active mode has one) is always accessible in ARM state via the special instructions MSR (move register to PRS) and MRS (move PRS to register). This register shows arithmetical instructions' additional results and allows to switch states/modes and interrupt handling. Its structure is shown below:

\vspace{5px}
\begin{adjustbox}{center}
\input{\specsd/tex/tables/CPSR.tex}
\end{adjustbox}
\vspace{5px}



The first 5 bits of CPSR are used to set processor execution mode, the possible values are:
\\

\begin{tabular}{r|l}
\texttt{0x10} & User Mode \\
\texttt{0x11} & Fast Interrupt Mode \\
\texttt{0x12} & Interrupt Mode \\
\texttt{0x13} & Supervisor Mode \\
\texttt{0x17} & Abort Mode \\
\texttt{0x1B} & Undefined Mode \\
\texttt{0x1F} & System Mode \\
\end{tabular}
\\

\emph{User Mode} is the only unprivileged mode, this means that if processor is running in \emph{User Mode} it cannot access \emph{reserved memory regions} (see System Bus chapter) and it cannot modify CPSR control bits.

\emph{System Mode} is the execution mode reserved for regular Kernel code execution, all other modes are activated when exceptions are being handled.

\asubsection{System Control Register}\label{sec:manual:systemControlRegister}

System Coprocessor (CP15) holds the System control register (CP15.R1), which controls Virtual Memory and thumb availability (plus some other hardware specific settings that are not implemented in current release):

\begin{itemize}
\item bit 0 : if set, the Memory Management Unit is enabled
\item bit 15 : if set, changes to T bit in CPSR are ignored
\end{itemize}

\asection{Processor States}

The \emph{T} flag of the Program Status Register shows the state of the processor, when the bit is clear the processor operates in ARM state, otherwise it works in Thumb state. To switch between the two states a Branch and Exchange (BX) instruction is required.

The first difference between the two states is the register set that is accessible (see previous section), the other main difference is the Instruction Set used.

\asubsection{ARM ISA}

The main Instruction Set is the ARM ISA, the processor starts execution in this state and switches to ARM state when entering exception handling sections.

ARM instructions are 32 bits long and must be word-aligned. The table below shows a brief summary of the instruction set. (For a much detailed description of each instruction refer to \emph{ARM7TMI Data Sheet} and \emph{ARM7TMI Technical Reference Manual})

\vspace{5px}
\begin{adjustbox}{center}
\input{\specsd/tex/tables/ARM_isa.tex}
\end{adjustbox}
\vspace{5px}

\asubsection{Thumb ISA}

Thumb instruction set is a simpler (smaller) instruction set composed of 16-bit, halfword aligned instructions, which offer less refined functionalities but less memory usage.

Thumb instructions can be seen as "shortcuts" to execute ARM code, as the performed operations are the same but this ISA offers less options for each instruction.

The following table summarizes Thumb instructions. (For a much detailed description of each instruction refer to \emph{ARM7TMI Data Sheet} and \emph{ARM7TMI Technical Reference Manual})

\vspace{5px}
\begin{adjustbox}{center}
\input{\specsd/tex/tables/Thumb_isa.tex}
\end{adjustbox}
\vspace{5px}

\asection{Exception Handling}

When an exception is raised (e.g. a read instruction is performed on a forbidden bus address), the processor automatically enter a special routine to solve the problem. 

In addition to low level automatic exception handling facilities, the BIOS code implements a simple wrapper to simplify OS level handlers setup and functioning.

\asubsection{Hardware Level Exception Handling}

There are seven different exceptions handled by the processor, each of those has a specific bus address to which the execution jumps on exception raising (see sec. \ref{sec:man:exceptionVector}).

When entering an exception handler, the processor stores a specific return address in the Link Return register and the Current Program Status Register is copied in a SPSR register both depending on the type of exception raised.

\asubsubsection{Reset Exception}
This exception is automatically raised each time the machine is started. 

This exception is handled in Supervisor mode with all interrupts disabled, Link Return and SPSR registers have unpredictable values and execution starts from bus address \texttt{0x00000000}.

\asubsubsection{Undefined Instruction Exception}
If a Coprocessor instruction cannot be executed from any Coprocessor or if an UNDEFINED instruction is executed, this exception is raised. 

Processor mode is set to Undefined, normal interrupts are disabled and Link Return register points to the instruction right after the one that caused the Undefined Exception.

\asubsubsection{Software Interrupt Exception}
This exception is caused by a SWI instruction and is meant to provide a neat way to implement System Calls. 

When handling Software Interrupt Exceptions, the processor switches to Supervisor mode with normal interrupts disabled and the Link Return register points to the instruction after the SWI that caused the exception.

\asubsubsection{Data Abort Exception}
If a the processor tries to access memory address that is not valid or available, this exception is raised.

When handling Data Aborts, the processor switches to Abort mode with normal interrupts disabled and Link Return register is set to the address of the instruction that caused the Abort plus 8.


\asubsubsection{Prefetch Abort Exception}
If the processor tries to execute an instruction that generated a data abort while being fetched, this exception is raised.

When handling Prefetch Aborts, the processor enters Abort mode with normal interrupts disabled and Link Return register points to the address of the instruction after the one that caused the exception.

\asubsubsection{Interrupt Request Exception}
When a connected Device requires the processor's attention, it fires an Interrupt Request.

When handling Interrupt Requests, the processor enters Interrupt mode with normal interrupts disabled and Link Return register is set to the address of the instruction that was not executed plus 4.

\asubsubsection{Fast Interrupt Request Exception}
Fast Interrupts have higher priority than normal Interrupts, also, system Interval Timer is connected to this line of interrupts. When the Timer changes its value from \texttt{0x00000000} to \texttt{0xFFFFFFFF}, a Fast Interrupt is requested.

When handling Fast Interrupt Requests, the processor enters Fast Interrupt mode with all interrupts disabled and Link Return register points to the address of the instruction that was not executed plus 4.

\asubsection{ROM Level Exception Handling}

During the bootstrap process, six of the seven bus registers containing handler jump calls must be initialized (the reset exception only occurs at system startup).
The BIOS code fills these registers with fixed jump instruction opcodes pointing to its internal handler procedures.

The BIOS exception handlers provide a safe and automatic way to enter kernel level handlers by storing the processor state as it was before the exception rose and loading the kernel handler's processor state from a known memory location inside the Kernel Reserved Frame (see sec. \ref{sec:man:kernelReservedFrame}).

In addition to this general behavior, some handlers provide other functionalities as described below.

\asubsubsection{Undefined Instruction Handler}

An Undefined Instruction Exception has no special functions other than the basic BIOS handlers behavior, it stores the old processor state into the PGMT Old Area and loads the processor state stored into the PGMT New Area.

\asubsubsection{Software Interrupt Handler}

Software interruptions recognized by the BIOS handler can be of two types: \emph{System Calls} or \emph{Breakpoints}, the foremost being interpreted as a request to the kernel, while the latter can also be a BIOS service request.

This handler is capable of recognizing BIOS service requests and serving them directly, if an unrecognized Breakpoint or a System Call is requested, the exception is handled with the default behavior, the old processor state is stored into the Syscall Old Area and the processor state stored into the Syscall New Area is loaded.

\asubsubsection{Data Abort and Prefetch Abort Handler}

If Virtual Memory is enabled (see sec. \ref{sec:man:virtualMemory}), both Data and Prefetch Aborts can be raised while accessing a memory frame whose VPN is not loaded into the TLB, event signaled by the memory subsystem through these two exceptions.
If this is the case, the BIOS will automatically perform a TLB\_Refill cycle searching the active Page Tables for the required entry, otherwise the exception is treated as a generic exception, storing the old processor state into TLB Old Area and then loading the processor state stored into the TLB New Area.

Since the two different exception types have different return address offsets, this handler shifts the return address stored with the old processor state to be the correct address to jump to, as discerning the exception type from kernel level handler could be quite difficult without the knowledge of the hardware level exception.

\asubsubsection{Interrupt and Fast Interrupt Handlers}

Both these exceptions are treated as generic exceptions and the BIOS handlers will adopt the default behavior, storing the old processor state into the Interrupt Old Area and then loading the processor state stored into the Interrupt New Area.


