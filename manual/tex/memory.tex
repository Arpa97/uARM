\achapter{Memory Interface}\label{sec:man:memory}
Memory system is controlled by Program Status Register (\register{CPSR}) and System Coprocessor's registers 1 and 2 (\register{CP15.R1} \& \register{CPSR.R2}). It supports two operating modes:

\begin{itemize}
\item physical addressing mode, 
\item virtual addressing mode.
\end{itemize}

In addition to address translation modes, the portion of accessible memory is dictated by processor operating mode:

\begin{itemize}
\item User mode $\rightarrow$ User Space
\item Privileged mode $\rightarrow$ All Memory
\end{itemize}

In each addressing mode these portions have a specific definition.

As stated in section \ref{sec:man:reservedAddressSpace}, addresses below \addr{0x0000.8000} are reserved for hardware/protected functions and belong to the \uline{reserved address space} independently from the active addressing mode.

\asection{Physical addressing mode}
This is the basic memory access scheme, when enabled, any memory access is directed to the physicall address specified in the request, without any conversions.
The machine begins execution with this mode active.

All the available memory is directly accessible in Privileged mode and any address over \addr{0x0000.8000} is directly accessible in User mode.

\spinput{mem_ph.tex}

Trying to access an address below \addr{0x0000.8000} while in User Mode will raise a \texttt{BUSERROR} exception.

\asection{Virtual addressing mode}\label{sec:man:virtualMemory}
When virtual memory is active, each address above \addr{0x0000.8000} is treated as a logical address and translated to the corresponding physical address from the memory subsystem, addresses below \addr{0x0000.8000} are always treated as physical addresses, as they refer to a memory region reserved for bus access.

By setting \field{M} flag in System Coprocessor's register 1 (\register{CP15.R1}.\field{M}), you enable memory address translation.

In Privileged mode all logical memory is accessible, when exacting in User mode, only User Segments are accessible instead: the first one (Useg2) starts from address \addr{0x8000.0000} and extends over the next GB, the second one (Useg3) starts from address \addr{0xC000.0000} and terminates at the top of the logical memory, address \addr{0xFFFF.FFFF}.

\spinput{mem_vir.tex}


When the MMU is enabled the user process ASID is stored in the EntryHy field of CP15's 64bit register R2 along with the Virtual Page number (e.g. the 20 most significant bits of the logical address). The EntryLow filed is filled with the Physical Page Frame address and is kept up to date after each modification of CP15.R2.EntryHy value.

\asubsection{Page Table}\label{sec:man:pageTable}
The CP15 register 2 is organized as a Page Table Entry (PTE):
\\

\spinput{CP15.R2.tex}

The Low half of each entry contains 4 flags used for memory protection:
\begin{itemize}
\item \textbf{N}on Chachable bit: not used by \uarm{} implementation.
\item \textbf{D}irty bit: if the bit is clear, any write access to the physical frame locations will rise a TLB-Modification exception.
\item \textbf{V}alid bit: if bit is set the Page Table Entry is considered valid, otherwise a TLB-Invalid exception is raised.
\item \textbf{G}lobal bit: if the bit is set, the Page Table Entry will match the corresponding VPN regardless of the ASID.
\end{itemize}

Page Table Entries are grouped together in Page Tables, each Page Table begins with a special word (PgTbl-Header) composed of the PgTbl Magic Number \texttt{0x2A} stored in the most significant 8 bits and the number of page table entries in the least significant 20 bits.

\spinput{pag_tbl.tex}


\asubsection{Segment Table}\label{sec:man:segmentTable}
The Segment Table specifies the physical addresses of the Page Tables of the three Segments for each ASID, the general structure is shown below:
\\

\spinput{seg_tbl.tex}

\uarm{} implements a Translation Lookaside Buffer (TLB) to translate logical addresses to physical ones, the buffer contains a specific amount of recently used PTEs and uses a random algorithm to select which entry to replace with a newly retrieved PTE.
The number of available TLB slots is variable between 4 and 64 elements, it is configurable through the settings window and needs a reset of the machine to effectively change.

Each time a memory access is requested, the memory subsystem checks if the requested virtual Page has a corresponding PTE in the TLB for the current ASID or with the \texttt{G} flag set, if this is the case it concatenates the physical frame address with the actual requested offset to access the right address.

If the necessary PTE is not present in the TLB, a TLB-Miss exception is raised and the BIOS reacts with a TLB Refill event, which executes the next steps:
\begin{enumerate}
\item Retrieve the PgTbl address from the Segment Table for the current ASID and required Segment.
\item Access the PgTbl and check if it is well-formed and well-located:
	\begin{itemize}
	\item Address must be greater than \addr{0x0000.8000},
	\item Address must be word aligned,
	\item PgTbl-Header must be valid (magic number is \texttt{0x2A}),
	\item PgTbl must not extend outside physical memory (e.g. [PgTbl addr + PgTbl size] $<$ RAMTOP).
	\end{itemize}
\item Linearly search the PgTbl for matching Virtual Page with correct ASID or \texttt{G} flag set.
\item If a matching PTE has been found, write it back in a random slot of the TLB and resume execution from the same instruction that raised the TLB-Miss exception, else raise a PTE-Miss exception.
\end{enumerate}

The random algorithm uses all the TLB slots besides the first one (e.g. item~0) to ensure a safe entry is always available.

\asubsubsection{ASID 0}
The first ASID is reserved for kernel address space and is automatically enabled in any Privileged mode, this way if a User mode program performs a System Call, the kernel routine has access to its address space and to the program's address space through saved processor state.


