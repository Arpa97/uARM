\chapter{System Bus}

The system bus connects each component of the system and lets processing units access physical memory and devices.

The CPU and the System Coprocessor (CP15) can directly access the bus reading or writing values from or to specific addresses.

The lower addresses (below \texttt{0x8000}) are reserved for special uses and are accessible under certain conditions.

\section{Reserved address space}
The address region between \texttt{0x0} and \texttt{0x8000} holds the fast exception vector, device registers, system informations, bootstrap rom and the kernel reserved frame. Any access to this memory area in User mode are (should be) prohibited and treated by the system bus as errors.

\subsection{Exception Vector}
The first locations (\texttt{0x0} $\rightarrow$ \texttt{0x1C}) are occupied by exception vector, the processor jumps automatically to these addresses if an exception is risen and the bootstrap rom tipically writes a set of branch instructions to exception handlers in these fields.

Exception vector is organized as follows:
\\

\begin{tabular}{r|l}
\texttt{0x0} & Reset \\
\texttt{0x4} & Undefined Instruction \\
\texttt{0x8} & Software Interrupt \\
\texttt{0xC} & Prefetch Abort \\
\texttt{0x10} & Data Abort \\
\texttt{0x14} & \emph{reserved} \\
\texttt{0x18} & Interrupt Request \\
\texttt{0x1C} & Fast Interrupt Request \\
\end{tabular}

\subsection{Installed Device Table}
Five words, from \texttt{0x20} to \texttt{0x30}, show the status of active devices. Each word represent a device line:
\\

\begin{tabular}{r|l}
\texttt{0x20} & Disks \\
\texttt{0x24} & Tapes \\
\texttt{0x28} & Netwok \\
\texttt{0x2C} & Printers \\
\texttt{0x30} & Terminals \\
\end{tabular}
\\

For each device line, if a specific device \emph{i} is enable, \emph{i}\textsuperscript{th} bit in representing word has value 1.

\subsection{Device Registers}
Addresses \texttt{0x40} to \texttt{0x2C0} hold device registers, the behavior of this memory region is the same as uMPS machine's.

\subsection{System Information Registers}
Six registers, from address \texttt{0x2D0} to \texttt{0x2E8}, show system specific informations:
\\

\begin{tabular}{r|l}
\texttt{0x2D0} & ram base address \\
\texttt{0x2D4} & ram top address \\
\texttt{0x2D8} & device registers base address \\
\texttt{0x2DC} & time of day (Hi) \\
\texttt{0x2E0} & time of day (Low) \\
\texttt{0x2E4} & interval timer \\
\texttt{0x2E8} & timer scale (fixed to 1 Mz) \\
\end{tabular}

\subsubsection{Interval Timer}

Interval timer is decremented at each cpu cycle, when its value becomes 0 a software interrupt is thrown. It can be set to a desired value by writing its address in any privileged mode.

\subsection{Bootstrap ROM}
The bootstrap rom is loaded starting from address \texttt{0x300}, its maximum size is 109 KB.
See BIOS chapter for details.

\subsection{Pending Interrupt Bitmap}
Most of the interrupt lines are shared through all the devices of the same class, to identify which device is requesting for interrupt there are five registers from address \texttt{0x6FE0} to \texttt{0x6FF0} that hold a bitmap of interrupting devices per interrupt line.

This region is organized exactly as the Installed Device Table:
\\

\begin{tabular}{r|l}
\texttt{0x6FE0} & Disks \\
\texttt{0x6FE4} & Tapes \\
\texttt{0x6FE8} & Netwok \\
\texttt{0x6FEC} & Printers \\
\texttt{0x6FF0} & Terminals \\
\end{tabular}
\\

For each word, \emph{i} bit is set if \emph{i}\textsuperscript{th} device on that line is requesting for interrupt.

\subsection{Kernel Reserved Frame}
The last memory frame (\texttt{0x7000} $\rightarrow$ \texttt{0x7FFC}) is reserved for kernel use:
\begin{itemize}
\item \texttt{0x7000} $\rightarrow$ \texttt{0x7500}: Exception states vector - memory area in which processor states are saved and loaded when entering into/exiting from exception handlers code.
\item \texttt{0x7600} $\rightarrow$ \texttt{0x7C00}: Segment table - here is stored the 128 elements segment table describing the virtual address space, for each ASID (entries in the segment table) there are two pointers to ASID's private and shared page tables.
\item \texttt{0x7FF0} $\rightarrow$ \texttt{0x7FFC}: Rom stack - when invoking rom functions this stack is used to pass parameters to the hardware routines.
\end{itemize}

\subsubsection{Stored Processor States}
Processor states are defined by library data structure \emph{state\_t}, this structure is composed of 20 unsigned 32-bit integers representing processor registers' values and coprocessor's system control registers' values. 

Its structure is shown below:
\nopagebreak
\\
\texttt{ typedef struct\{}

\nopagebreak
\texttt{unsigned int a1;\ \ \ \ //r0}

\nopagebreak
\texttt{unsigned int a2;\ \ \ \ //r1}

\nopagebreak
\texttt{unsigned int a3;\ \ \ \ //r2}

\nopagebreak
\texttt{unsigned int a4;\ \ \ \ //r3}

\nopagebreak
\texttt{unsigned int v1;\ \ \ \ //r4}

\nopagebreak
\texttt{unsigned int v2;\ \ \ \ //r5}

\nopagebreak
\texttt{unsigned int v3;\ \ \ \ //r6}

\nopagebreak
\texttt{unsigned int v4;\ \ \ \ //r7}

\nopagebreak
\texttt{unsigned int v5;\ \ \ \ //r8}

\nopagebreak
\texttt{unsigned int v6;\ \ \ \ //r9}

\nopagebreak
\texttt{unsigned int sl;\ \ \ \ //r10}

\nopagebreak
\texttt{unsigned int fp;\ \ \ \ //r11}

\nopagebreak
\texttt{unsigned int ip;\ \ \ \ //r12}

\nopagebreak
\texttt{unsigned int sp;\ \ \ \ //r13}

\nopagebreak
\texttt{unsigned int lr;\ \ \ \ //r14}

\nopagebreak
\texttt{unsigned int pc;\ \ \ \ //r15}

\nopagebreak
\texttt{unsigned int cpsr;}

\nopagebreak
\texttt{unsigned int CP15\_Control;}

\nopagebreak
\texttt{unsigned int CP15\_EntryHi;}

\nopagebreak
\texttt{unsigned int CP15\_Cause;}\\
\nopagebreak
\texttt{\}state\_t; }
\\

These structures take 80 bytes each. Given this value, the BIOS code will look for the Old/New enties at the following addresses:
\\

\begin{tabular}{r|l}
\texttt{0x7000} & Interrupt Old \\
\texttt{0x7080} & Interrupt New \\
\texttt{0x7100} & TLB Old \\
\texttt{0x7180} & TLB New \\
\texttt{0x7200} & PGMT Old \\
\texttt{0x7280} & PGMT New \\
\texttt{0x7300} & Syscall Old \\
\texttt{0x7380} & Syscall New \\
\end{tabular}

\subsubsection{ASOD 0}
The first ASID is reserved for kernel address space and is automatically enabled in any Privileged mode, this way if a User mode program performs a System Call, the kernel routine has access to its address space and to the program's address space through saved processor state.

\section{Memory address space}

The remainig addresses are mapped to memory subsystem and can be accessed through a number of instructions, see Memory Interface chapter for details.